import glob
import numpy as np
import os.path as path
from scipy import misc
IMAGE_PATH = './benign_images_cropped/'
file_paths = glob.glob(path.join(IMAGE_PATH, '*.png'))
# print(file_paths)

MAL_IMAGE_PATH = './malware_images_cropped/'
mal_file_paths = glob.glob(path.join(MAL_IMAGE_PATH, '*.png'))
# print(file_paths)

# Load the images
images = [misc.imread(path) for path in file_paths]
images = np.asarray(images)
# print(images)

# Load the malware images
mal_images = [misc.imread(path) for path in mal_file_paths]
mal_images = np.asarray(mal_images)
# print(images)


# Get image size
image_size = np.asarray([images.shape[1], images.shape[2]])
# Get malware image size
mal_image_size = np.asarray([mal_images.shape[1], mal_images.shape[2]])
# print(image_size)

# image pixel - 256
images = images / 255
mal_images = mal_images /255
# print(mal_images.shape)

# Read the labels from the filenames
n_images = images.shape[0]
n_mal_images = mal_images.shape[0]
# print(n_images)
# print(n_mal_images)


total_n_images=n_images+n_mal_images
# print(total_n_images)
# print(images.shape)
# print(mal_images.shape)
# keep all the images  and labels together
images = np.concatenate((images,mal_images))
# images=np.reshape(total_n_images,(256,256,total_n_images))
# images.reshape((256,256,58))
# print(images.shape)

labels = np.zeros(n_images)
mal_labels = np.ones(n_mal_images)
labels = np.append(labels,mal_labels)



# Split into test and training sets
TRAIN_TEST_SPLIT = 0.9

# Split at the given index
split_index = int(TRAIN_TEST_SPLIT * total_n_images)
shuffled_indices = np.random.permutation(total_n_images)
train_indices = shuffled_indices[0:split_index]
test_indices = shuffled_indices[split_index:]

# Split the images and the labels
x_train = images[train_indices, :]
y_train = labels[train_indices]
x_test = images[test_indices]
y_test = labels[test_indices]

# print(x_test[0].shape)
# print(y_train)
# print(y_train[1])


import keras
from keras.models import Sequential, Input, Model
from keras.layers import Dense, Dropout, Flatten
from keras.layers import Conv2D, MaxPooling2D
from keras.layers.normalization import BatchNormalization
from keras.layers.advanced_activations import LeakyReLU

width = 256

# print(total_n_images)
train_X = x_train.reshape(-1, width, width, 1)
test_X = x_test.reshape(-1, width, width, 1)
print(y_train)
print(y_test)
# y_train = y_train.reshape(-1,1,1,1)
# print(y_train.shape)
# y_train = keras.utils.to_categorical(y_train,1)
# print(train_X.shape)
# print(y_train.shape)

# y_train.reshape(-1,1,1,1);
# print(y_train)
# exit()

# Network parameters:

batch_size = 64
epochs = 25
num_classes = 1

# Architecture

Malware_Model = Sequential()
Malware_Model.add(Conv2D(64,
                         kernel_size=(3, 3),
                         activation='linear',
                         input_shape=(width, width, 1),
                         padding='same'))
Malware_Model.add(LeakyReLU(alpha=0.1))
Malware_Model.add(MaxPooling2D(pool_size=(2, 2),
                               padding='same'))
Malware_Model.add(Conv2D(32, (3, 3),
                         activation='linear',
                         padding='same'))
Malware_Model.add(LeakyReLU(alpha=0.1))
# Malware_Model.add(Dense(256,
#                         activation='linear'))
# Malware_Model.add(LeakyReLU(alpha=0.1))
# Malware_Model.add(Dropout(0.4))
Malware_Model.add(Flatten())
# Malware_Model.add(Dropout(0.5))
Malware_Model.add(Dense(50, activation='relu'))
Malware_Model.add(Dense(num_classes,
                        activation='softmax'))

# Compile the model
Malware_Model.compile(loss=keras.losses.binary_crossentropy,
                      optimizer=keras.optimizers.Adam(),
                      metrics=['accuracy'])

# Visualize the Malware_Model
print(Malware_Model.summary())

from keras.utils import plot_model
plot_model(Malware_Model, to_file='model.png')
# from ann_visualizer.visualize import ann_viz;
# ann_viz(Malware_Model, title="Malware_Model.png")

# Fit and Train the model:

Malware_Model.fit(train_X, y_train,
                  batch_size=batch_size,
                  epochs=epochs,
                  verbose=1)
                #   validation_data=(valid_X, valid_label))

# Evaluste the model
# print('The accuracy of the Test is:', test_eval[1])
print(Malware_Model.metrics)
print(Malware_Model.metrics_names)
loss , acc = Malware_Model.evaluate(test_X, 
                                    y_test, 
                                    verbose=1)
print(loss)
print(acc)

pred = Malware_Model.predict(test_X);
for i,j in zip(y_test, pred):
  print(i,j[0])