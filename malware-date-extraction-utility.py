from collections import Counter
from os import listdir
import csv
import pydasm
from time import time
from random import randint

INSTR_SET = {

    'mov', 'xchg', 'stc', 'clc', 'cmc', 'std', 'cld', 'sti', 'cli', 'push', 'pushf', 'pusha', 'pop', 'popf', 'popa', 'ccombw', 'cwd', 'cwde', 'in', 'out', 'add', 'adc', 'sub', 'sbb', 'div', 'idiv', 'mul', 'imul', 'inc', 'dec', 'cmp', 'sal', 'sar', 'rcl', 'rcr', 'rol', 'ror', 'neg', 'not', 'and', 'or', 'xor', 'shl', 'shr', 'nop', 'lea', 'int', 'call', 'jmp', 'je', 'jz', 'jcxz', 'jp', 'jpe', 'ja', 'jae', 'jb', 'jbe', 'jna', 'jnae', 'jnb', 'jnbe', 'jc', 'jnc', 'ret', 'jne', 'jnz', 'jecxz', 'jnp', 'jpo', 'jg', 'jge', 'jl', 'jle', 'jng', 'jnge', 'jnl', 'jnle', 'jo', 'jno', 'js', 'jns', 'jns', 'popa', 'rol', 'popf', 'jnz', 'imul', 'lds', 'jna', 'jng', 'jno', 'jnl', 'arpl', 'cli', 'cld', 'clc', 'add', 'adc', 'scasd', 'scasb', 'daa', 'mov', 'das', 'nop', 'repne', 'jnc', 'cmc', 'leave', 'jmpf', 'cmp', 'hlt', 'loope', 'pusha', 'pushf', 'out', 'xor', 'sub', 'rep', 'ret', 'jecxz', 'xchg', 'cwd', 'lea', 'jz', 'jp', 'js', 'jl', 'jo', 'jg', 'ja', 'jc', 'sbb', 'sahf', 'stosb', 'movsd', 'movsb', 'les', 'xlat', 'or', 'into', 'bound', 'pop', 'fildl', 'retf', 'retn', 'fadds', 'faddl', 'call', 'wait', 'sldt', 'fiaddl', 'jmp', 'int1', 'int3', 'std', 'aad', 'aaa', 'stc', 'aam', 'sti', 'aas', 'lahf', 'dec', 'loop', 'and', 'jpo', 'int', 'lock', 'in', 'flds', 'fldl', 'cbw', 'fild', 'inc', 'cmpsb', 'callf', 'cmpsd', 'test', 'fiadd', 'stosd', 'insb', 'outsv', 'iret', 'outsb', 'insv', 'loopne', 'salc', 'lodsb', 'lodsd', 'enter', 'push'
}

dll_disassemble_suf = ".dlldisassemble"


def get_opcodes_from_asm_file(file_path):
    """
    Reads the disassembly file and extracts all the opcodes used.
    (opcodes that counts are those in INSTR_SET)
    :param file_path: The path to the asm file
    :return: A list with all the opcodes from INSTR_SET (as str) in the file
    """
    opcodes = []
    for line in file(file_path):
        if not line.startswith(".text") and not line.startswith("CODE"):
            continue
        line = line.split()
        if len(line) < 3:  # no opcode
            continue
        for s in line[1:]:
            if s in INSTR_SET:
                opcodes.append(s)
                break
            elif s == ';':
                break

    return opcodes


def disassemble_dll(file_path):
    f = open(file_path, "rb")
    buff = f.read()
    f.close()
    instructions = []

    offset = 0
    while offset < len(buff):
        i = pydasm.get_instruction(buff[offset:], pydasm.MODE_32)
        if not i:
            break
        instructions.append(pydasm.get_instruction_string(
            i, pydasm.FORMAT_INTEL, 0))
        offset += i.length
    return instructions


def get_opcodes_of_disassembly_list(disassembly):
    opcodes = []
    for instr in disassembly:
        if instr:
            split = instr.split()
            for op in split:
                if op in INSTR_SET:
                    opcodes.append(op)
                    break
    return opcodes


def disassemble_to_file(file_path, new_file_name):
    dis = disassemble_dll(file_path)
    with open(new_file_name, "w") as f:
        for instruction in dis:
            f.write(instruction + "\n")
    return dis